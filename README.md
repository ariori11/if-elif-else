Модуль 2
2.2 if, else, elif
Цель: применить навыки создания условных конструкций и знания операторов / and, or, not.

Задача "Все ли равны?":
На вход программе подаются 3 целых числа и записываются в переменные first, second и third соответственно.
Ваша задача написать условную конструкцию (из if, elif, else), которая выводит кол-во одинаковых чисел среди 3-х введённых.

Пункты задачи:
1.	Если все числа равны между собой, то вывести 3
2.	Если хотя бы 2 из 3 введённых чисел равны между собой, то вывести 2
3.	Если равных чисел среди 3-х вообще нет, то вывести 0

Пример результата выполнения программы:
Ввод в консоль 1:
123
456
789

Вывод на консоль 1:
0

Ввод в консоль 2:
42
69
42

Вывод на консоль 2:
2

Примечания:
1.	Помните, что условная конструкция начинается с if.
2.	Операторы elif и else не могут существовать самостоятельно, они являются продолжением условной конструкции.
3.	Старайтесь избегать вложенности условий и описывать их, используя операторы or, and и not.
4.	Самое хорошее решение не только самое быстрое, но ещё и хорошо читаемое!

2.3 цикл while
Цель: применить навыки создания цикла while, а так же применения операторов break и continue.

Задача "Нули ничто, отрицание недопустимо!":
Дан список чисел [42, 69, 322, 13, 0, 99, -5, 9, 8, 7, -6, 5]
Нужно выписывать из этого списка только положительные числа до тех пор, пока не встретите отрицательное или не закончится список (выход за границу).

Пункты задачи:
1.	Запишите исходный список в переменную my_list.
2.	Напишите цикл while с соответствующими задаче условиями.
3.	Используйте операторы прерывания/продолжения цикла в соответствии с условиями задачи.

Результат выполнения программы:
Исходные данные:
my_list = [42, 69, 322, 13, 0, 99, -5, 9, 8, 7, -6, 5]

Вывод на консоль:
42
69
322
13
99

Примечания:
1.	Чтобы перебрать список вам понадобиться обращение по индексу, запишите в отдельную переменную начальное значение - 0.
2.	Чтобы не выйти за границу списка, в условии цикла while рекомендуется сравнивать текущий индекс и длину списка (функция len()).
3.	Оператор continue - возвращает вас к условию цикла, игнорируя код после себя, break - прерывает цикл.
4.	0 - не отрицательное и не положительное число.

2.4 цикл for

Цель: закрепить навык решения задач при помощи цикла for, применив знания об основных типах данных.

Задача "Всё не так уж просто":
Дан список чисел numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
Используя этот список составьте второй список primes содержащий только простые числа.
А так же третий список not_primes, содержащий все не простые числа.
Выведите списки primes и not_primes на экран(в консоль).
Пункты задачи:
1.	Создайте пустые списки primes и not_primes.
2.	При помощи цикла for переберите список numbers.
3.	Напишите ещё один цикл for (вложенный), где будут подбираться делители для числа из 1ого цикла.
4.	Отметить простоту числа можно переменной is_prime, записав в неё занчение True перед проверкой.
5.	В процессе проверки на простоту записывайте числа из списка numbers в списки primes и not_primes в зависимости от значения переменной is_prime после проверки (True - в prime, False - в not_prime).
6.	Выведите списки primes и not_primes на экран(в консоль).

Пример результата выполнения программы:
Исходный код:
 numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
Вывод на консоль:
Primes: [2, 3, 5, 7, 11, 13]
Not Primes: [4, 6, 8, 9, 10, 12, 14, 15]
Примечания:
1.	Учтите, что число 1 не является ни простым, ни составным числом, поэтому оно отсутствует в конечных списках.
2.	Для проверки на простоту числа вам нужно убедиться, что выбранное число не делиться ни на что в диапазоне от 2 до этого числа(не включительно).
3.	Попробуйте оптимизировать(ускорить) процесс выяснения простоты числа при помощи оператора break, когда найдёте делитель. (Не обязательно)
4.	Переменные меняющее своё булевое состояние на противоположное в процессе проверки, как is_prime, в кругах разработчиков называются перменными-флагами(flag).


2.5 Функции, функции с параметром.
Цель: закрепить навык написания функций и их вызовов.

Задача "Матрица воплоти":
Напишите функцию get_matrix с тремя параметрами n, m и value, которая будет создавать матрицу(вложенный список) размерами n строк и m столбцов, заполненную значениями value и возвращать эту матрицу в качестве результата работы.

Пункты задачи:
1.	Объявите функцию get_matrix и напишите в ней параметры n, m и value.
2.	Создайте пустой список matrix внутри функции get_matrix.
3.	Напишите первый(внешний) цикл for для кол-ва строк матрицы, n повторов.
4.	В первом цикле добавляйте пустой список в список matrix.
5.	Напишите второй(внутренний) цикл for для кол-ва столбцов матрицы, m повторов.
6.	Во втором цикле пополняйте ранее добавленный пустой список значениями value.
7.	После всех циклов верните значение переменной matrix.
8.	Выведите на экран(консоль) результат работы функции get_matrix.

Пример результата выполнения функции:
Исходный код:
result1 = get_matrix(2, 2, 10)
result2 = get_matrix(3, 5, 42)
result3 = get_matrix(4, 2, 13)
print(result1)
print(result2)
print(result3)
Вывод на консоль:
[[10, 10], [10, 10]]
[[42, 42, 42, 42, 42], [42, 42, 42, 42, 42], [42, 42, 42, 42, 42]]
[[13, 13], [13, 13], [13, 13], [13, 13]]
Примечания:
1.	Вложенный список - это строка матрицы, элементы вложенных списков(глубже) - это столбцы матрицы.
2.	В случае передачи аргумента со значением 0 или меньше, будет возвращаться пустой список.



Доп задание

Дополнительное практическое задание по модулю: "Основные операторы"

Цель: Применить знания полученные в модуле, решив задачу повышенного уровня сложности

Задание "Слишком древний шифр":
Вы отправились в путешествие на необитаемый остров и конечно же в очередной вылазке в джунгли вы попали в ловушку местному племени (да-да, классика "Индиана Джонса").
К вашему удивлению, в племени были неплохие математики и по совместительству фантазёры.
Вы поняли это, когда после долгих блужданий перед вами появились ворота (выход из ловушки) с двумя каменными вставками для чисел.
В первом поле камни с числом менялись постоянно (от 3 до 20) случайным образом, а второе было всегда пустым.

К вашему счастью рядом с менее успешными и уже неговорящими путешественниками находился папирус, где были написаны правила для решения этого "ребуса". (Как жаль, что они поняли это так поздно :( ).

Во вторую вставку нужно было написать те пары чисел друг за другом, чтобы число из первой вставки было кратно(делилось без остатка) сумме их значений.

Пример кратности(деления без остатка):
1 + 2 = 3 (сумма пары)
9 / 3 = 3 (ровно 3 без остатка)
9 кратно 3 (9 делится на 3 без остатка)


Пример 1:
9 - число из первой вставки
1218273645 - нужный пароль (1 и 2, 1 и 8, 2 и 7, 3 и 6, 4 и 5 - пары; число 9 кратно сумме каждой пары)

Пример 2:
11 - число из первой вставки
11029384756 - нужный пароль (1 и 10, 2 и 9, 3 и 8, 4 и 7, 5 и 6 - пары; число 11 кратно сумме каждой пары)


К сожалению, у вас не так много времени, чтобы подбирать пароль вручную, шипы сверху уже движутся на вас (обожаю клише), тем более числа в первой вставке будут попадаться случайно.

Составьте алгоритм, используя циклы, чтобы в независимости от введённого числа n (от 3 до 20) программа выдавала нужный пароль result, для одного введённого числа.

Что является парой?:
Пары являются уникальными на примере следующего:
7 3 3 5 8
В этой последовательности уникальными парами являются:
Для первой 7: 73 73 75 78
Для второй 3: 33 35 38 (с первой 7 у этой 3 уже есть пара, поэтому её не берём).

Все пароли для чисел от 3 до 20 (для сверки):
3 - 12
4 - 13
5 - 1423
6 - 121524
7 - 162534
8 - 13172635
9 - 1218273645
10 - 141923283746
11 - 11029384756
12 - 12131511124210394857
13 - 112211310495867
14 - 1611325212343114105968
15 - 1214114232133124115106978
16 - 1317115262143531341251161079
17 - 11621531441351261171089
18 - 12151811724272163631545414513612711810
19 - 118217316415514613712811910
20 - 13141911923282183731746416515614713812911

Отдельно по числам, для большего понимания:
3 - 1+2
4 - 1+3
5 - 1+4 2+3
6 - 1+2 1+5 2+4
7 - 1+6 2+5 3+4
8 - 1+3 1+7 2+6 3+5
...
18 - 1+2 1+5 1+8 1+17 2+4 2+7 2+16 3+6 3+15 4+5 4+14 5+13 6+12 7+11 8+10
19 - 1+18 2+17 3+16 4+15 5+14 6+13 7+12 8+11 9+10
20 - 1+3 1+4 1+9 1+19 2+3 2+8 2+18 3+7 3+17 4+6 4+16 5+15 6+14 7+13 8+12 9+11
Примечания:
1.	Можно использовать как цикл for, так и цикл while
2.	Пары чисел подбираются от 1 до 20 для текущего числа.


